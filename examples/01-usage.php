<?php

// include this file or add your autoloader


// and import your local config

// controller mac address
if(!defined('CONFIG_BTMAC')) {
  define('CONFIG_BTMAC', 'AA:BB:CC:DD:EE:FF');
}


// HCI commands and events
// https://www.bluetooth.com/wp-content/uploads/Files/Specification/HTML/Core-54/out/en/host-controller-interface/host-controller-interface-functional-specification.html#UUID-ee8bbec6-ebdd-b47d-41d5-a7e655cad979

use SharkyDog\BlueZ;

function pn($d) {
  print "*** Ex.01: ".print_r($d,true)."\n";
}

// HCI commands and hcidump need to run as root!
// HCI commands are blocking.

// MAC address of the controller
// hci interface name can also be used,
// but these tend to change numbers sometimes
$btmac = CONFIG_BTMAC;

// Get an instance of the controller
// A simple object that holds mac address and interface name (hciX)
if(!($bt = BlueZ\HCI::adapter($btmac))) {
  pn('Adapter not found!');
  exit;
}

// A custom command result to read the name from HCI_Read_Local_Name command
class ReadLocalNameResult extends BlueZ\HCI\CommandResult {
  public $name = '';

  public function __construct(BlueZ\HCI\CommandResult $ret) {
    parent::__construct($ret);

    if($this->ret) {
      $ret = trim(hex2bin($this->ret),"\x0");
      $this->ret = bin2hex($ret);
      $this->name = $ret;
    }
  }
}

// extend SharkyDog\BlueZ\HCI class and add commands
class HCI extends BlueZ\HCI {
  // HCI_Read_Local_Name
  public static function readLocalName(string $hci): ReadLocalNameResult {
    // execute command ogf 0x03, 0cf 0x0014 on controller $hci
    $ret = self::cmd($hci, 0x03, 0x0014);
    // parse result into SharkyDog\BlueZ\HCI\CommandResult
    $ret = self::cmdRet($ret, 0);
    // convert to ReadLocalNameResult
    $ret = new ReadLocalNameResult($ret);
    return $ret;
  }

  // HCI_Write_Local_Name
  public static function writeLocalName(string $hci, string $name): BlueZ\HCI\CommandResult {
    // convert name to array of integers (uint8)
    $params = unpack('C*', $name);
    // trim to 248 bytes
    $params = array_slice($params, 0, 248);
    // pad to 248 bytes with a null byte
    $params = array_pad($params, 248, 0);
    $ret = self::cmd($hci, 0x03, 0x0013, ...$params);
    $ret = self::cmdRet($ret, 0);
    return $ret;
  }
}


// Handlers for hcidump.
//
// Used by SharkyDog\BlueZ\HCIDump to filter its output,
// so a given listener is called only on a specific event
// or when a specific command was executed.
// The listeners will receive a new object
// of the class given as a filter,
// but with parsed event or command data.
//
// Listeners can also be attached for all events or all commands,
// then the received object will be
// SharkyDog\BlueZ\HCIDump\Event\Unknown or
// SharkyDog\BlueZ\HCIDump\Command\Unknown
//
// The hcidump process will auto start when a listener is attached
// and stop when all listeners are removed.


// command handler, when the host sends a command to the controller
// HCI_Set_Event_Mask command
// Usually executed by hciconfig reset, along with many many other commands.
//
class SetEventMaskCommand extends BlueZ\HCIDump\Command {
  // required
  public $ogf = '03';
  public $ocf = '0001';

  // filled when parsed
  public $maskInt = 0;
  public $maskStr = '';
  public $hasLeMeta = false;

  protected function _parse(string $opcode, string $params, BlueZ\HCIDump $hcid): ?self {
    $params = str_pad($params,8,"\x0",STR_PAD_RIGHT);

    $ret = new self;
    $ret->maskInt = unpack('P', $params)[1];

    // byte order can be confusing
    $maskBinBE = pack('J',$ret->maskInt);
    $ret->maskStr = '0x'.strtoupper(bin2hex($maskBinBE));
    $ret->hasLeMeta = ($ret->maskInt & (1 << 61)) != 0;

    return $ret;
  }
}

// event handler, when the controller has some data for the host
// HCI_Command_Complete
// Generated by the controller after most commands
// and has the return parameters of the command.
// Same data as in SharkyDog\BlueZ\HCI\CommandResult
// returned by a SharkyDog\BlueZ\HCI command.
//
class CommandCompleteEvent extends BlueZ\HCIDump\Event {
  public $code = '0E';
  public $result = null;

  protected function _parse(string $code, string $params, BlueZ\HCIDump $hcid): ?self {
    $rethex = bin2hex($params);
    $evt = new self;
    // parse the command status and return using SharkyDog\BlueZ\HCI\CommandResult
    $evt->result = HCI::cmdRet($rethex, 0);
    return $evt;
  }
}

$hcid = new BlueZ\HCIDump($bt);

// https://github.com/reactphp/child-process/blob/0.6.x/README.md#termination
$hcid->on('exit', function($code,$term) {
  pn('HCIDump exited: '.($term === null ? 'code: '.$code : 'signal: '.$term));
});


// To listen for all commands or events,
// call onCommand() or onEvent() only with a callback.

// add a command listener and remove it on first received
$cmd1_idx = null;
$cmd1_idx = $hcid->onCommand(function(SetEventMaskCommand $cmd) use($hcid,&$cmd1_idx) {
  $hcid->removeCommandListener($cmd1_idx);
  pn($cmd);
}, new SetEventMaskCommand);

// add an event listener
$evt1_idx = null;
$evt1_idx = $hcid->onEvent(function(CommandCompleteEvent $evt) use($hcid,&$evt1_idx) {
  // only interested in HCI_Read_Local_Name command result
  if($evt->result->ogf != '03' || $evt->result->ocf != '0014') {
    return;
  }
  $evt->params = rtrim($evt->params,'0');
  // convert SharkyDog\BlueZ\HCI\CommandResult to ReadLocalNameResult
  $evt->result = new ReadLocalNameResult($evt->result);
  $hcid->removeEventListener($evt1_idx);
  pn($evt);
}, new CommandCompleteEvent);


//HCI::reset($bt->hci);
//pn(HCI::writeLocalName($bt->hci, 'MyPC BT1'));
pn(HCI::readLocalName($bt->hci));

$res = HCI::setEventMask($bt->hci,0x3DBFF807FFFBFFFF); // all without reserved bits
pn($res);
// if non-root, this command will fail
// and SetEventMaskCommand listener above will never be called
// hcidump will continue running and this example will not exit
if(!$res->ok) {
  $hcid->removeCommandListener($cmd1_idx);
}
